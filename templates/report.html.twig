{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <div class="two-col-layout">
    <aside class="aside">
        <div>
            <h4>Innehållsförtäckning</h4>
            <ul>
                <li><a href="#kmom01">kmom01</a></li>
                <li><a href="#kmom02">kmom02</a></li>
                <li><a href="#kmom03">kmom03</a></li>
                <li><a href="#kmom04">kmom04</a></li>
                <li><a href="#kmom05">kmom05</a></li>
                <li><a href="#kmom06">kmom06</a></li>
                <li><a href="#kmom10">kmom10</a></li>
            </ul>
        </div>
    </aside>

    <main class="main courier">
            <h1>Redovisning</h1>
            <h2 id="kmom01">kmom01</h2>
            <p>
                Jag har läst kursen objektorienteradpython och upplevde att det var lite nytt tänk då för mig men in i kmom03 kändes allting ganska logiskt. Jag kan lite granna om 
                objektorientering och tycker inte att jag upplevde att den var svår då.
            </p>
            <p>
                Det som man behöver veta, för att kunna skapa en klass i PHP är att objektorienterad programmering är som vanlig (procedurprogrammering) programmering men vi inkapslar
                in metoder (som vi annars kallar för funktioner) och medlemsvariabler (variabler). Vi initierar en class med nyckelordet class och vi kan initiera en objekt som får
                med sig “alla” variabler och metoder som kan nås med this→.
            </p>
            <p>
                Jag upplever att kodbasen påminner ganska mycket om ramverket PICO som vi har arbetat med under kursen design. Jag upplever att de liknar mycket i logiken och i
                strukturen. Inga konstigheter tycker jag och strukturen verkar logisk och enkelt att förstå. Det blir säkert lite komplikationer på vägen men just nu under kmom01
                verkar den mycket lik PICO.
            </p>
            <p>
                Kapitel 4: Language highlights och i den nämns namespaces som låter rimligt och logiskt men jag vill prova öva för att veta mer om hur det fungerar. Kapitel 5:
                Dependency management är också mycket intressant. Nu i kurser får vi nästan alltid färdig bakad när det är arbetsmiljö vilket jag tycker är verkligen bra annars
                skulle man ju fastna mycket i början men det är något jag verkligen skulle vilja lära mig mer om. Det  finns många andra saker också men jag håller mig kort här.
            </p>
            <h3>TIL</h3>
            <p>
                Grunden i symfony liksom om bilder, twig och router. Grundläggande intro till class i objektorienterad PHP.
            </p>
            <h2 id="kmom02">kmom02</h2>
            <p>
                Med hjälp av arv kan en klass ärva metoder och medlemsvariabler från basklassen så att subklass kan specialisera basklass genom att återanvända koden.
                Komposition betyder att en klass innehåller andra objekt från en annan klass som delar sin funktionalitet. Tex. en die och en hand. En hand kan innehålla flera die
                därmed en hand är en komposition av die.
            </p>
            <p>
                Ett trait är som ett multipelarv som kan återanvändas i flera olika klasser. Jag förstår det som att man kan definiera en funktion som en modul som kan anropas från
                samma källa i olika moduler. Men i objektorienterad blir det alltså trait så att samma kod kan användas (use) i flera andra klasser utan arv. Interface är ett löfte
                som tvingar en klass att implementera eller erbjuda metoder. Med hjälp av interface vet man vad en klass kommer att kunna hantera.
            </p>
            <p>
                Jag har tre klasser för att lösa uppgiften: en som skapar en card och en som skapar grafisk presentation av kortet genom att ersätta exempelvis “hearts” mot symbolen
                av hearts. Jag har en tredje klass Deck som då loopar genom två arrays och skapar en hel deck. CardGraphic har Card som basklass och Deck är en composition av
                CardGraphic.
            </p>
            <p>
                För att lösa uppgiften och uppfylla krav skapar jag en deck när landningssida för den här uppgiften öppnas. Det görs endast om det inte finns en befintlig deck och
                mha. det kan man få sin resterande deck i länken card/deck. Om man vill skapa en ny deck, då får man trycka på card/shuffle. När det gäller draw ett eller flera kort
                använder jag mig av metoder som är definierade i Deck klass. Jag är typ nöjd med min presentation av kortlek. Jag utnyttjar twig och kollar om kommande string har
                en viss value för att tilldela css klass så att jag kan få hjärta och rutor röda osv. Det hade kunnat lösa snyggare bilder tycker jag. Jag tror det funkar nu men
                det kan förbättras.När det gäller koden i klasser evaluerar jag med min begränsad kunskap att det ser bra ut. Jag kanske har en annan syn på det om någon vecka då
                får jag ändra koden enligt det.
            </p>
            <p>
                Tankesätt och arbetssätt skiljer väl inte så mycket från tidigare kurser trots att det är viss skillnad i strukturen. Jag upplever jobbet i symfony med applikationskod
                som en blandning av arbetet i webtec (exempelvis skapa olika sidor/views osv.) och arbetet i design (Ramverk Pico som också innehöll en del twig filer).
            </p>
            <h3>TIL</h3>
            <p>
                Mer om objektorienterad PHP: arv (i praktik), komposition (i praktik), trait (i teori) och interface (i teori). Namespace och hur man startar session i symfony.
            </p>
            <h2 id="kmom03">kmom03</h2>
            <p>
                Jag känner absolut att skriva psuedokod och rita flödeschema var något som hjälpte mig mycket. Jag upplever att vanligt fall när vi arbetar med uppgifter finns det
                särskilda krav som på ett smidigt sätt stöder lösning av ett större problem och på det viset blir det ofta lättare att börja lösa uppgiften. Uppgiften kontextualseras
                automatisk av sina krav. Ett sådant problem som vi hade den här veckan kan verka mer abstrakta i början eftersom man måste skapa en kontext till problemet själv. Jag
                upplever alltid att det svåraste är att veta var och när man ska börja. Jag tyckte om tipsen KISS så att det blir en lättare start. Sen när man har kommit in i problemet
                då kan man lägga fokus på mer avancerade detaljer.
            </p>
            <p>
                Flödesschema och pseudokod gav mig en bättre bild på kontexten så att jag kunde bryta ner problemet och arbeta med mindre och mer konkreta delar. Dvs. jag byggde mina
                egna mindre krav för att nå målen som kunde testas innan fortsättning till nästa nivå så att jag kunde undvik att hamna i en komplex labyrint. Min lösning blev en
                blandning av top down och bottom up strategin. Jag upplever att det är lika viktigt att kunna titta på problemet utifrån ett komplex perspektiv också så som att kunna titta på
                ett problem i mindre delar. För mig blev det först att bryta ner på problemet till mindre delar och sedan när jag var klar med mina egna krav då behövde jag ändå kolla
                på problemet utifrån ett större perspektiv för att kontrollera sammanhanget mellan mindre delar. En sista sak som jag tror mycket starkt på är att läsa problemet och
                låta hjärna arbeta med det på egen hand innan man ens startar och tack för påminnelse. 

            </p>
            <p>
                Jag behövde inte skriva mycket kod när det gäller att bygga mer klasser. Jag har använt koden från kmom01 och kmom02. Jag behövde skapa en ny klass som ärver från
                Deck(): en klass som jag använt i kmom02. Den nya klassen innehåller två nya metoder som kunde ha skrivits i Deck() men jag ville hålla koden lätt i varje klass. Kod
                i kontroller och router är ganska tunt och i mesta del handlar koden om att anropa metoder och använda session, därför upplever jag att jag löst uppgiften ganska
                effektivt. Jag  skriver en hel del kod i kontroller och skapar flera routes och tempelates för att lösa uppgiften.
            </p>
            <p>
                Jag ångrar mig lite nu i kmom03 att jag körde med den enklaste metoden när det gäller att presentera ett kort. Jag borde ha använt images så att korten kan se lite mer verkliga ut
                och inte som kladd. Jag vågade och orkade inte riktigt att börja om, däremot har jag lagt lite tid på CSS och Twig-filer så att mina kort ser lite bättre ut än vad de
                gjorde från början. Jag tror att det finns mycket potential när det gäller att skriva ren och snygg kod. Jag körde lint och började fixa så att det ser så bra ut som
                möjligt. Jag har kommit upp till nivå-5, det är allt grönt tills det. Därefter dyker det upp några anmärkningar. Annars kodmässigt känner jag mig ganska nöjd just nu,
                jag återanvänder min kod i de flesta fall när det går.
            </p>
            <p>
                Jag upplever inga nyheter eller att jag har blivit tvungen att lära mig nya tekniker i kmom03 när det gäller symfony. Jag tycker att symfony är mycket smidigt när det
                gäller router och hur namespace fungerar men utöver det har den här kmom mer handlat om problemlösning och planera sin kod och exekvera den upplever jag. Jag upplever
                att jag bara har repeterat det som jag hade lärt mig från kmom02 när det gäller symfony annars har det varit utmanande och spännande att planera och lösa uppgiften.
            </p>
            <h3>TIL</h3>
            <p>
                Flödesschema, problemlösning, mer om twig och static funktioner.
            </p>
            <h2 id="kmom04">kmom04</h2>
            <p>
                Jag har tidigare läst objektorienterad python och PHPUnit kändes inte konstigt. Det upplevdes lite mer som repetition av det som vi tidigare har gjort i python. Jag tycker och håller med
                litteraturen att det är mycket smidigare att testa sin egen kod då och då innan det blir för stort så att det blir ett naturligt flöde. Samtidigt tycker att det blir lite svårare att testa
                sin egen kod till fullo som Marie nämnde i sin föreläsning. Allmänt tycker jag att det är mycket bra praktik och det blir lättare att skapa sina egna kontrollstationer så att det blir en
                ordning på koden. Speciellt med white box testing som vi gjorde nu så att vi vet koden och våra förväntningar på den som bör testas då och då under processen.
            </p>
            <p>
                Av min erfarenhet från oopython visste jag att det kan bli komplicerat med objektorienterad programmering därför gjorde jag mina egna kontroller redan från kmom01. Dvs. min stil var lite
                mer “Test Driven Development”, min tanke var inte unit tester från kmom01 men det var lite mer verification och debugging av min kod längst vägen. Jag lyckades med mer än 90% kodtäckning
                utan några bekymmer.
            </p>
            <p>
                Jag upplevde att det största delen av koden var testbar men jag fick lite problem med statiska metoder som jag hade och jag har refaktoriserat min kod så att det blir testbar. Jag var
                tvungen att gå tillbaka och ändra lite för game21 från kmom03 också men allting fungerar och alla metoder kunde testas.
            </p>
            <p>
                Jag hade en metod som jag hade definierat som statisk och det gick inte att testa eller det gick att testa men jag fick problem med att linta min kod. Jag ändrade min metod till en
                publikmetod så det löste sig. Det finns mycket potential för att förbättra min kod men att testa koden var inga stora bekymmer.
            </p>
            <p>
                Jag har läst om att testa med hjälp av mocka objekt och jag tror att jag förstår också varför det kan behövas men bland mina tester har jag inga sådana tester. Jag har inte några external
                dependencies eller några slumpmässiga händelser i min kod därför har jag inte använt mocking. Mina testar i stort sätt testar deterministisk logik och det har gått bra att texta utan att
                skapa stub eller mocka. Jag upplevde inte från krav att man var tvungen att skapa någon sådan test därför har jag låtit det bli. Säger du till kan jag ersätta och använda mocking bara för
                visandets skull.
            </p>
            <p>
                Jag upplever att testbar kod måste inte vara en identifikation för snygg och ren kod men i de flesta fall bör det innebära det. Dvs. om kod är testbar bör det innebära att koden är rent
                och skriven i enkla icke komplexa metoder vilket då innebär att all kod blir testbar. På det viset skulle det kunna påstås att testbar kod kan vara en identifierare till snygg och ren kod
                men i motsatt riktning behöver inte det stämma alls. Om koden är snygg och ren kommer det inte automatiskt innebära att den är testbar, koden måste vara funktionell också så att
                funktionaliteten kan testas.
            </p>
            <h3>TIL</h3>
            <p>
                Unittesta i PHP, verktyg phpunit och mocka ett objekt för testning.
            </p>
            <h2 id="kmom05">kmom05</h2>
            <p>
                Jag upplevde att det gick bra att arbeta med övningen och det var smidigt att följa instruktioner. Det var några saker som jag reagerade på: ena hur smidigt det var att skapa en databas och
                använda den. Det vill säga om någon inte har full koll på SQL kan ändå arbeta med databasen. Samtidigt tyckte jag det var irriterande att inte ha koll på vad som händer i bakgrunden.
                Exempelvis att jag gjorde övningen i me/report så att jag hade Produkt i report som jag ville ta bort efteråt och var lite rädd ifall jag skulle sabba även Library. Det var bara en reaktion,
                i verkligheten när jag började läsa då var det väl inte så svårt att ta bort Product Entity. Jag upplevde också att det var mycket smidigt hur Doctrine skapade databaskopplingar och entity
                mapping automatiskt. Man kunde även välja att skapa unit tester så att det genererades automatiskt. Mycket smidigt att man fick med alla getters och setters också.
            </p>
            <p>
                Jag tänkte att /library ska vara tydlig och enkel att följa. Det ska gå att läsa och vara användarvänligt när det gäller design och flödet i appen måste vara logiskt. Jag tänkte också på
                responsivitet, exempelvis att användaren får flash-meddelande om man lyckas uppdatera, radera eller skapa en ny bok. Ovan nämnda faktorer finns med i appen och det går smidigt att följa men
                några andra saker som jag kunde ha gjort mer men jag inte har gjort är att det bör kontrollera vilken typ av input som kommer, kanske köra try and catch så att felmeddelande kan visas för
                användare. Jag använder sådant meddelande endast en gång då library är tom, då uppmanas användaren att lägga till en bok men det bör göras vid några andra tillfällen också. Sammanfattningsvis
                kan man säga att fokus var på att ge användaren bra erfarenhet.
            </p>
            <p>
                Det gick bra att arbeta med Object-Relational Mapping. Jag är inte säker, men att arbeta med CRUD i ORM upplevdes som en mycket latare version av SQL. Exemepelvis remove() som används för
                att radera ett objekt automatiskt och det händer magiska grejer i bakgrunden hade kunnat skötas med en lagrad procedurer. Jag förstår att det blir smidigare med ORM men hade jag behövt
                arbeta i större omfattning då hade jag ändå velat använda SQL så att jag vet och kan se vad som händer i bakgrunden.
            </p>
            <p>
                Jag tror att en del av det här besvarats ovan men att arbeta med ORM påminner mycket om så som vi arbetat i webtec men där använde vi istället riktig SQL och nu finns det flera alternativ
                för att kunna arbeta SQL. Det kan väljas att arbeta med SQL, querrybuilding osv. Jag valde ändå att arbeta med querrybuilding så att jag får lära mig något nytt. I ORM blir koden mycket
                renare och koden är samlat på olika ställen och mycket sköts automatiskt och magiskt. Vilket jag upplever kan vara lika bra som dåligt. Det kanske beror på hur mycket kontrollbehov man har.
            </p>
            <h3>TIL</h3>
            <p>
                CRUD i Object-Relational Mapping och lite mer om att kunna escapa validering i phpmd.
            </p>
            <h2 id="kmom06">kmom06</h2>
            <p>
                Jag uppfattade verktyget mycket användbart som ger en översiktlig bild av kodkvaliteten. De bitar som jag uppskattade mycket var att man kunde sila koden
                utifrån klasser eller metoder särskilt för att kunna se komplexiteten. En annan sak som var mycket intressant är att det kunde visualisera coupling av en
                klasser så att det blev lättare att se sin egen kod. Bland bilder uppskattade jag mycket färgkodade bollar som representerade klasser. Bollar visade
                komplexiteten och maintaibabillity index. Det tyckte jag var mycket intressant för att kunna få en snabb blick om sin egen kod.
            </p>
            <p>
                Jag upplevde att det var mycket jobbigt och frustrerande att integrera Scrutinizer. Det tog mycket tid att integrera och det kändes som att man var ute
                i en värld utan något kontroll. Jag hade mycket problem även för att få mina unittester att köras när det gällde tester för mina twig-klasser. Verktyget
                i sig tyckte jag var bra. Man kunde få en bra överblick om sin kod och badges som en markör för sin kod. Det kändes bra. Jag fick kodtäckning på 13% och
                kodkvalitet 10. Jag hade inte gjort några unittester för mina kontrollklasser i kmom04 därför blev det ganska låg med coverage om man räknar alla klasser.
            </p>
            <p>
                Min syn på kodkvalitet har varit att den ska vara läsbar och så liten som möjligt utan att komplicera den för mycket. Jag har i min tidigare kod använt
                en rads looper med arraymaping osv. men jag föredrar inte. Jag vill att koden ska vara läsbar, variabler och metoder ska definieras på ett sätt så att man
                själv ska kunna förstå sin kod om någon månad utan för stort ansträngning. Nu när vi arbetat med php-verktyg, phpmetrics och scrutinizer förstår jag
                behovet av att styra clean code lite mer och hur den skulle kunna underlätta arbetslivet genom att sätta samma krav på alla. Jag tycker att till viss mån
                badges reflekterar kodkvalitet exempelvis innan badges tyckte jag att jag hade ganska bra coverage men det var väldigt dåligt när jag såg på siffrorna.
                Däremot fick jag ge mig efter ett tag. Det kostade mig för mycket tid för att kunna få min build att passera på scrutinizer med unittester för twig.
                Man kanske behöver avgöra själv vad som är tillräckligt bra istället för jaga badges.
            </p>
            <h3>TIL</h3>
            <p>
                Metrics, scrutinizer och konstruera session för tester samt 6:C.
            </p>
            <h2 id="kmom10">kmom10</h2>
    </main>

</div>


{% endblock %}